-- nodeLogic :: HostName -> ServiceName -> ReaderT NodeInfo IO NodePeersState
-- nodeLogic bip bport = do
--   info <- ask
--   (pub, _) <- liftIO $ generateWallet 2048
--   state <- liftIO $ newIORef emptyNodePeersState
--   trigger <- liftIO newEmptyMVar
-- 
--   let ip = nodeIP info :: HostName
--       port = nodePort info :: ServiceName
--       msg = encodeStrict (pub, ip, port)
--       page = 4096
-- 
--       getIDfromBoot :: IORef NodePeersState -> (Socket, SockAddr) -> IO ()
--       getIDfromBoot ioref (socket, _) = do
--         send socket msg
--         resp <- recv socket 32 -- 32 bytes enough to hold an Int
--         modifyIORef' ioref $ \s -> s {nodeID = decodeMaybe resp}
-- 
--       getBroadcast :: MVar Int -> IORef NodePeersState -> (Socket, SockAddr) -> IO ()
--       getBroadcast mvar ioref (socket, _) = do
--         resp <- recv socket $ 8 * page -- 32KB ~ 100 nodes
--         let (keys, friends, genesis) = decodeMaybe resp :: ([PublicKey], [(HostName, ServiceName)], Block)
--             accountMap = Map.fromList $ map (,emptyAccount) keys
--             peers = map (uncurry NodeInfo) friends
--         modifyIORef' ioref $ \s -> s {nodeAccounts = accountMap, nodePeers = peers, nodeBlockchain = [genesis]}
--         putMVar mvar 1
--   -- connect to the boot to get your id
--   _ <- liftIO $ connect bip bport $ getIDfromBoot state
--   -- setup server to receive broadcast
--   _ <- liftIO $ forkIO $ serve (Host ip) port $ getBroadcast trigger state
--   _ <- liftIO $ takeMVar trigger -- wait for the broadcast to finish
--   liftIO $ readIORef state -- return the final state


-- mint :: ReaderT NodePeersState (State NodeBlockchainState) () 
-- mint = do
--   info <- ask
--   let myid = nodeID info
--       mypub = fst $ nodeWallet info
--       myaccounts = Map.elems $ nodeAccounts info
--       fees = txsFee $ nodeTxs info
--       lastblock = head $ nodeBlockchain info
--       prevhash = decode $ BS.fromStrict $ blockCurrentHash lastblock
-- 
--       sampleValidator :: (RandomGen g) => g -> [(Double, Int)] -> Int
--       sampleValidator g probs = evalState (sampleStateRVar (weightedCategorical probs)) g
-- 
--       -- slight detail: the lottery is not the ID of the validator
--       -- but the index of the validator in the sorted list of public keys.
--       -- this is just for me to avoid changing the node info type.
--       weights = zip (map accountStake myaccounts) [1 .. length myaccounts]
--       validator = sampleValidator (mkStdGen prevhash) weights
--       valkey = fst $ Map.elemAt validator $ nodeAccounts info
--       -- add the fees to the account of the validator
--       newAccs = Map.update plusFees valkey $ nodeAccounts info
--         where plusFees acc = Just acc {accountBalance = accountBalance acc + fees}
-- 
--       broadcastBlock :: Block -> ReaderT NodePeersState IO ()
--       broadcastBlock block = do
--         mypeers <- asks nodePeers
--         mapM_ sendBlock mypeers
--         where msg = encodeStrict block
--               sendBlock :: NodeInfo -> ReaderT NodePeersState IO ()
--               sendBlock NodeInfo {nodeIP = h, nodePort = p} = do
--                 liftIO $ connect h p $ \(sock, _) -> send sock msg
-- 
--   if validator == myid then
--     do
--       currtime <- liftIO getUnixTime
--       let newblock =
--             Block
--               { blockIndex = blockIndex lastblock + 1,
--                 blockTimestamp = currtime,
--                 blockTransactions = nodeTxs info,
--                 blockValidator = mypub,
--                 blockPreviousHash = blockCurrentHash lastblock,
--                 blockCurrentHash = BS.empty
--               }
--           newState = info {nodeTxs = [], nodeAccounts = newAccs, nodeBlockchain = newblock : nodeBlockchain info}
--       broadcastBlock newblock
--       return newState
--     else return info    -- get block, validate it, return modified state.
